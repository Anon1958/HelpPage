import os
import time
import subprocess
from pathlib import Path

# --- CONFIG ----------------------------------------------------
# Point this at your shortcut (.lnk) or the actual EXE.
# From your screenshot it looks like the shortcut lives here:
WEBEX_SHORTCUT = r"C:\Users\iams395\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Webex\Webex.lnk"

# How long to keep Webex open each cycle (minutes)
OPEN_MINUTES = 5

# Optional: wait time after closing before opening again (minutes)
GAP_MINUTES = 0
# ---------------------------------------------------------------

# Common Webex process names to kill; adjust if your Task Manager shows different names
PROCESS_NAMES = [
    "Webex.exe",
    "WebexPT.exe",
    "webexmta.exe",
    "webexhost.exe",
    "atmgr.exe"  # sometimes part of Webex stack
]

def launch_webex():
    path = Path(WEBEX_SHORTCUT)
    if not path.exists():
        raise FileNotFoundError(f"Cannot find Webex at: {path}")
    # start the .lnk or .exe
    os.startfile(str(path))  # uses ShellExecute; works with .lnk
    print(f"[+] Launched Webex via {path}")

def kill_webex():
    # Quietly attempt to kill all known Webex processes
    for name in PROCESS_NAMES:
        subprocess.run(
            ["taskkill", "/IM", name, "/F"],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            creationflags=subprocess.CREATE_NO_WINDOW
        )
    print("[+] Closed Webex (taskkill issued)")

def main():
    open_secs = int(OPEN_MINUTES * 60)
    gap_secs  = int(GAP_MINUTES * 60)

    print(f"Starting Webex pulser: open {OPEN_MINUTES} min, gap {GAP_MINUTES} min. Ctrl+C to stop.")
    try:
        while True:
            launch_webex()
            time.sleep(open_secs)
            kill_webex()
            if gap_secs:
                time.sleep(gap_secs)
    except KeyboardInterrupt:
        print("\n[!] Stopping on user request…")
        kill_webex()

if __name__ == "__main__":
    main()
    
    
    
    
    
    import os
import time
import subprocess
from pathlib import Path
import platform

# ====== CONFIG ======
WEBEX_TARGET = r"C:\Users\iams395\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Webex\Webex.lnk"
OPEN_SECONDS = 2     # "pretty much instantly" (minimum 1 sec so the process spawns)
GAP_SECONDS  = 2     # short pause before reopening
KEEP_AWAKE   = True  # keep display/system from sleeping while running
# ====================

# Common Webex processes to terminate
PROCESS_NAMES = [
    "Webex.exe", "WebexPT.exe", "webexmta.exe",
    "webexhost.exe", "CiscoCollabHost.exe",
    "wbxsvc.exe", "ptoneclk.exe", "atmgr.exe"
]

def set_keep_awake(enable: bool):
    """Prevent display/system sleep while this Python process runs (Windows only)."""
    if platform.system() != "Windows":
        return
    import ctypes
    ES_CONTINUOUS       = 0x80000000
    ES_SYSTEM_REQUIRED  = 0x00000001
    ES_DISPLAY_REQUIRED = 0x00000002
    flags = ES_CONTINUOUS | ES_SYSTEM_REQUIRED | ES_DISPLAY_REQUIRED if enable else ES_CONTINUOUS
    ctypes.windll.kernel32.SetThreadExecutionState(flags)
    print(f"[+] Keep-awake {'ENABLED' if enable else 'DISABLED'}")

def launch_webex():
    path = Path(WEBEX_TARGET)
    if not path.exists():
        raise FileNotFoundError(f"Cannot find Webex shortcut/exe at: {path}")
    os.startfile(str(path))  # works with .lnk or .exe
    print("[+] Opened Webex")

def kill_webex():
    cf = getattr(subprocess, "CREATE_NO_WINDOW", 0)
    for name in PROCESS_NAMES:
        subprocess.run(
            ["taskkill", "/F", "/T", "/IM", name],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            creationflags=cf
        )
    print("[+] Closed Webex")

def main():
    open_s = max(1, int(OPEN_SECONDS))
    gap_s  = max(1, int(GAP_SECONDS))
    print(f"Pulse mode: open ~{open_s}s, gap ~{gap_s}s. Press Ctrl+C to stop.")

    try:
        if KEEP_AWAKE:
            set_keep_awake(True)

        while True:
            launch_webex()
            time.sleep(open_s)
            kill_webex()
            time.sleep(gap_s)

    except KeyboardInterrupt:
        print("\n[!] Stopping…")
    finally:
        # restore normal sleep behavior and make sure Webex isn't left running
        try:
            if KEEP_AWAKE:
                set_keep_awake(False)
        finally:
            try:
                kill_webex()
            except Exception:
                pass
        print("[+] Done. Sleep restored.")

if __name__ == "__main__":
    main()
    
    
    
    
    



















import os
import time
import subprocess
from pathlib import Path
import platform
import ctypes

# ====== CONFIG ======
WEBEX_TARGET = r"C:\Users\iams395\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Webex\Webex.lnk"

# "Instant-ish" pulse
OPEN_SECONDS       = 1      # how long to keep Webex open before closing
GAP_SECONDS        = 2      # pause after closing before reopening

# Click settings
CLICK_AFTER_OPEN   = True   # click once after Webex launches
WAIT_BEFORE_CLICK  = 1.0    # seconds to give Webex time to appear
CLICK_COORDS       = None   # (x, y) to click; None = auto-pick a likely empty area
DOUBLE_CLICK       = False  # set True to double-click

# Keep-awake
KEEP_AWAKE         = True   # prevent system/display sleep while script runs
# ====================

# Known Webex process names
PROCESS_NAMES = [
    "Webex.exe", "WebexPT.exe", "webexmta.exe",
    "webexhost.exe", "CiscoCollabHost.exe",
    "wbxsvc.exe", "ptoneclk.exe", "atmgr.exe"
]

def set_keep_awake(enable: bool):
    """Prevent display/system sleep while this Python process runs (Windows only)."""
    if platform.system() != "Windows":
        return
    ES_CONTINUOUS       = 0x80000000
    ES_SYSTEM_REQUIRED  = 0x00000001
    ES_DISPLAY_REQUIRED = 0x00000002
    flags = ES_CONTINUOUS | ES_SYSTEM_REQUIRED | ES_DISPLAY_REQUIRED if enable else ES_CONTINUOUS
    ctypes.windll.kernel32.SetThreadExecutionState(flags)
    print(f"[+] Keep-awake {'ENABLED' if enable else 'DISABLED'}")

def launch_webex():
    path = Path(WEBEX_TARGET)
    if not path.exists():
        raise FileNotFoundError(f"Cannot find Webex shortcut/exe at: {path}")
    os.startfile(str(path))
    print("[+] Opened Webex")

def kill_webex():
    cf = getattr(subprocess, "CREATE_NO_WINDOW", 0)
    for name in PROCESS_NAMES:
        subprocess.run(
            ["taskkill", "/F", "/T", "/IM", name],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            creationflags=cf
        )
    print("[+] Closed Webex")

def _screen_size():
    user32 = ctypes.windll.user32
    return user32.GetSystemMetrics(0), user32.GetSystemMetrics(1)  # (width, height)

def _get_cursor_pos():
    class POINT(ctypes.Structure):
        _fields_ = [("x", ctypes.c_long), ("y", ctypes.c_long)]
    pt = POINT()
    ctypes.windll.user32.GetCursorPos(ctypes.byref(pt))
    return pt.x, pt.y

def _set_cursor_pos(x, y):
    ctypes.windll.user32.SetCursorPos(int(x), int(y))

def _click_left():
    MOUSEEVENTF_LEFTDOWN = 0x0002
    MOUSEEVENTF_LEFTUP   = 0x0004
    ctypes.windll.user32.mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)
    ctypes.windll.user32.mouse_event(MOUSEEVENTF_LEFTUP,   0, 0, 0, 0)

def click_somewhere(coords=None, double=False):
    """Click a likely empty area on the primary screen (or custom coords)."""
    # Save current pointer
    oldx, oldy = _get_cursor_pos()

    if coords is None:
        w, h = _screen_size()
        # Aim near bottom-right but above taskbar ~60px and away from edges ~20px
        x = max(20, int(w * 0.90) - 20)
        y = max(20, int(h * 0.90) - 60)
    else:
        x, y = coords

    _set_cursor_pos(x, y)
    _click_left()
    if double:
        time.sleep(0.1)
        _click_left()

    # Return pointer to where it was
    _set_cursor_pos(oldx, oldy)
    print(f"[+] Clicked at ({x}, {y})")

def main():
    open_s = max(1, int(OPEN_SECONDS))
    gap_s  = max(1, int(GAP_SECONDS))
    print(f"Pulse: open ~{open_s}s, gap ~{gap_s}s. Ctrl+C to stop.")

    try:
        if KEEP_AWAKE:
            set_keep_awake(True)

        while True:
            launch_webex()
            if CLICK_AFTER_OPEN:
                time.sleep(max(0.1, WAIT_BEFORE_CLICK))
                click_somewhere(coords=CLICK_COORDS, double=DOUBLE_CLICK)

            time.sleep(open_s)
            kill_webex()
            time.sleep(gap_s)

    except KeyboardInterrupt:
        print("\n[!] Stopping…")
    finally:
        try:
            if KEEP_AWAKE:
                set_keep_awake(False)
        finally:
            try:
                kill_webex()
            except Exception:
                pass
        print("[+] Done. Sleep restored.")

if __name__ == "__main__":
    main()
    
    
    
    
    
    
    
    
    
    
    
    
    
    
import os, time, subprocess, platform, ctypes
from pathlib import Path

# ====== CONFIG ==================================================
WEBEX_TARGET        = r"C:\Users\iams395\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Webex\Webex.lnk"
WAIT_FOR_WINDOW_S   = 1.2   # time to let the window appear
OPEN_SECONDS        = 2     # how long to keep Webex open each cycle
GAP_SECONDS         = 2     # pause after closing before reopening
KEEP_AWAKE          = True  # prevent display/system sleep while running
WINDOW_TITLE_HINT   = "webex"  # substring to find the Webex window
# ================================================================

PROCESS_NAMES = [
    "Webex.exe", "WebexPT.exe", "webexmta.exe",
    "webexhost.exe", "CiscoCollabHost.exe",
    "wbxsvc.exe", "ptoneclk.exe", "atmgr.exe"
]

user32 = ctypes.windll.user32
kernel32 = ctypes.windll.kernel32

def set_keep_awake(enable: bool):
    if platform.system() != "Windows":
        return
    ES_CONTINUOUS       = 0x80000000
    ES_SYSTEM_REQUIRED  = 0x00000001
    ES_DISPLAY_REQUIRED = 0x00000002
    flags = ES_CONTINUOUS | ES_SYSTEM_REQUIRED | ES_DISPLAY_REQUIRED if enable else ES_CONTINUOUS
    kernel32.SetThreadExecutionState(flags)
    print(f"[+] Keep-awake {'ENABLED' if enable else 'DISABLED'}")

def launch_webex():
    path = Path(WEBEX_TARGET)
    if not path.exists():
        raise FileNotFoundError(f"Cannot find Webex shortcut/exe at: {path}")
    os.startfile(str(path))
    print("[+] Opened Webex")

def kill_webex():
    cf = getattr(subprocess, "CREATE_NO_WINDOW", 0)
    for name in PROCESS_NAMES:
        subprocess.run(
            ["taskkill", "/F", "/T", "/IM", name],
            stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, creationflags=cf
        )
    print("[+] Closed Webex")

def find_window_by_title_substr(substr: str, timeout: float = 5.0):
    substr = substr.lower()
    EnumWindows = user32.EnumWindows
    IsWindowVisible = user32.IsWindowVisible
    GetWindowTextLengthW = user32.GetWindowTextLengthW
    GetWindowTextW = user32.GetWindowTextW

    WNDENUMPROC = ctypes.WINFUNCTYPE(ctypes.c_bool, ctypes.c_void_p, ctypes.c_void_p)
    found_hwnd = ctypes.c_void_p(0)

    @WNDENUMPROC
    def enum_proc(hwnd, lParam):
        nonlocal found_hwnd
        if not IsWindowVisible(hwnd):
            return True
        length = GetWindowTextLengthW(hwnd)
        if length == 0:
            return True
        buf = ctypes.create_unicode_buffer(length + 1)
        GetWindowTextW(hwnd, buf, length + 1)
        title = buf.value.lower()
        if substr in title:
            found_hwnd = ctypes.c_void_p(hwnd)
            return False  # stop enumeration
        return True

    end = time.time() + timeout
    while time.time() < end and not found_hwnd.value:
        EnumWindows(enum_proc, 0)
        if found_hwnd.value:
            break
        time.sleep(0.2)
    return found_hwnd.value

def focus_window(hwnd):
    if not hwnd:
        return False
    SW_RESTORE = 9
    user32.ShowWindow(hwnd, SW_RESTORE)
    time.sleep(0.05)
    ok = user32.SetForegroundWindow(hwnd)
    return bool(ok)

def get_window_rect(hwnd):
    rect = (ctypes.c_long * 4)()
    user32.GetWindowRect(hwnd, rect)
    left, top, right, bottom = rect
    return left, top, right, bottom

def _set_cursor_pos(x, y):
    user32.SetCursorPos(int(x), int(y))

def _click_left():
    MOUSEEVENTF_LEFTDOWN = 0x0002
    MOUSEEVENTF_LEFTUP   = 0x0004
    user32.mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)
    user32.mouse_event(MOUSEEVENTF_LEFTUP,   0, 0, 0, 0)

def click_in_window_center(hwnd):
    # remember cursor
    class POINT(ctypes.Structure):
        _fields_ = [("x", ctypes.c_long), ("y", ctypes.c_long)]
    pt = POINT()
    user32.GetCursorPos(ctypes.byref(pt))
    oldx, oldy = pt.x, pt.y

    l, t, r, b = get_window_rect(hwnd)
    x = int((l + r) / 2)
    y = int((t + b) / 2)
    _set_cursor_pos(x, y)
    time.sleep(0.05)
    _click_left()
    time.sleep(0.05)
    _set_cursor_pos(oldx, oldy)
    print(f"[+] Clicked inside Webex at ({x},{y})")

def send_alt_space_then_escape():
    # Harmless in-app keystroke: open window menu (Alt+Space) then close (Esc)
    VK_MENU  = 0x12
    VK_SPACE = 0x20
    VK_ESC   = 0x1B
    KEYEVENTF_KEYUP = 0x0002
    user32.keybd_event(VK_MENU, 0, 0, 0)               # Alt down
    user32.keybd_event(VK_SPACE, 0, 0, 0)              # Space down
    user32.keybd_event(VK_SPACE, 0, KEYEVENTF_KEYUP, 0)# Space up
    user32.keybd_event(VK_MENU, 0, KEYEVENTF_KEYUP, 0) # Alt up
    time.sleep(0.12)
    user32.keybd_event(VK_ESC, 0, 0, 0)                # Esc down
    user32.keybd_event(VK_ESC, 0, KEYEVENTF_KEYUP, 0)  # Esc up
    print("[+] Sent Alt+Space, then Esc")

def main():
    open_s = max(1, int(OPEN_SECONDS))
    gap_s  = max(1, int(GAP_SECONDS))
    print(f"Pulse: open ~{open_s}s, gap ~{gap_s}s. Ctrl+C to stop.")

    try:
        if KEEP_AWAKE:
            set_keep_awake(True)

        while True:
            launch_webex()
            time.sleep(WAIT_FOR_WINDOW_S)

            hwnd = find_window_by_title_substr(WINDOW_TITLE_HINT, timeout=3.0)
            if hwnd and focus_window(hwnd):
                time.sleep(0.1)
                # Do both: a click INSIDE the Webex window + a harmless key combo
                click_in_window_center(hwnd)
                send_alt_space_then_escape()
            else:
                # Fallback: tiny mouse jiggle to reset OS idle timer
                class POINT(ctypes.Structure):
                    _fields_ = [("x", ctypes.c_long), ("y", ctypes.c_long)]
                pt = POINT()
                user32.GetCursorPos(ctypes.byref(pt))
                _set_cursor_pos(pt.x + 1, pt.y)
                _set_cursor_pos(pt.x, pt.y)
                print("[!] Could not focus Webex window; did a small jiggle instead")

            time.sleep(open_s)
            kill_webex()
            time.sleep(gap_s)

    except KeyboardInterrupt:
        print("\n[!] Stopping…")
    finally:
        try:
            if KEEP_AWAKE:
                set_keep_awake(False)
        finally:
            try:
                kill_webex()
            except Exception:
                pass
        print("[+] Done. Sleep restored.")

if __name__ == "__main__":
    main()